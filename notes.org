#+TITLE: Syncthing in Rust

Some notes about trying to understand how syncthing works by trying to implement parts of it in rust.

* Keys and device ids
** key pair
A key pair is generated the first time: private key + public key (stored as an X509 certificate). The key pair is used to do a TLS handshake with other peers.

*** X509 certificates
**** PEM
The keys are stored in PEM format (basically ascii-armored way to attach binary data): base64 data between delimiters:

   #+begin_src
-----BEGIN FOO-----
<data goes here>
-----END FOO-----
   #+end_src

The binary data encoded in the PEM file is the certificate encoded with ASN.1 and serialized with DER.
**** ASN.1
ASN.1 defines a way to encode data in data structures i.e. defines a grammar for a set of types, with their fields.

The general structure of a certificate, encoded as ASN.1, is as follows:
#+begin_src
    Certificate
        Version Number
        Serial Number
        Signature Algorithm ID
        Issuer Name
        Validity period
            Not Before
            Not After
        Subject name
        Subject Public Key Info
            Public Key Algorithm
            Subject Public Key
        Issuer Unique Identifier (optional)
        Subject Unique Identifier (optional)
        Extensions (optional)
            ...
    Certificate Signature Algorithm
    Certificate Signature
#+end_src
**** DER
=DER= is a _type-length-value_ way to serialize data such as ASN.1 into bytes.

** Device ID
- SHA-256 hash of the certificate (the DER-encoded binary data)
- base-32 encoded
- in recent versions the device ID contains 4 checksum digits (1 every 13 characters), so the length of the ID is 56 instead of 52. See Luhn's algorithm.
- '-' are inserted every 7 characters for readability purposed
* Local discovery
** Listening for announcement packets on the local network
- Listens for UDP messages broadcasted on port 21027. Registers the announced devices in a cache.
- The cache is used to resolve device ids
** announce current device on the network
- every 30-60s broadcast an =Announce= packet on the network

* Connecting to a peer
- Try to resolve the device id to get addresses to connect to, by looking through different "providers" eg. config file, local discovery, global discovery, etc.
- Connect to the address with TLS while presenting our own certificate
- exchange =Hello= packet
- Verify that the remote certificate (there should be only one) matches the device ID we expect.
* Implementation
** Next steps:
- [X] Set up protocol negotiation for bep/1.0
- [X] Send a =Hello= packet back
- [X] Verify peer's certificate
- [ ] Keep the connection open and handle incoming messages
** Libs
- Use Tokio for the async stuff...
- Use tokio-tls (and in particular tokio_rustls) for TLS stuff: wraps rustls in an async API and integrates with tokio
- [ ] Use =tracing= for logging
- Can =tokio-tower= be useful here?
** TLS stuff
When connecting 2 peers, they each offer their certificates / key as part of the TLS handshake, but it does *not* do client authentication (as the certificates are self-signed). Unfortunately, =rustls= doesn't seem to support this scenario out of the box...
- =NoClientAuth= doesn't do client authentication, but doesn't request the peer certificate
- =AllowAnyAuthenticatedClient= and =AllowAnyAnonymousOrAuthenticatedClient= do request the peer certificate, but try to validate it (and fail)

The workaround was to implement a custom =ClientCertVerifier= that requests the peer certificate but doesn't do authentication (or rather, accepts everything...). It required enable the =dangerous_configuration= feature on the =rustls= crate to access the =ClientCertVerifier= trait.
